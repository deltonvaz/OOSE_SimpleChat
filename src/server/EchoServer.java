// This file contains material supporting section 3.7 of the textbook:// "Object Oriented Software Engineering" and is issued under the open-source// license found at www.lloseng.com package server;import java.io.*;import java.util.Observable;import java.util.Observer;import common.ChatIF;import ocsf.server.*;/** * This class overrides some of the methods in the abstract  * superclass in order to give more functionality to the server. * * @author Dr Timothy C. Lethbridge * @author Dr Robert Lagani&egrave;re * @author Fran&ccedil;ois B&eacute;langer * @author Paul Holden * @author Delton Vaz (edition for OOSE) * @author William D'amico (edition for OOSE) * @version November 2018 */public class EchoServer implements Observer{	//Class variables *************************************************	/**	 * The default port to listen on.	 */	final public static int DEFAULT_PORT = 5555;	/**	 * Attributes 	 */	private ChatIF serverUI;	private ObservableServer oServer;	//Constructors **************************************************** 	/**	 * Constructs an instance of the echo server using Observer	 * @param serverUI The server user interface used.	 * @param port The port number to connect on.	 */	public EchoServer(ChatIF serverUI, int port) 	{		this.oServer = new ObservableOriginatorServer(port);		this.oServer.addObserver(this);		this.serverUI = serverUI;	}	//Instance methods ************************************************	/**	 * Call listen method from observableServer attr.	 * @throws IOException	 */	public void listen() throws IOException {		this.oServer.listen();	}	/**	 * Sympa close	 */	public void closeSafe() {		this.oServer.sendToAllClients("#logoff");		try {			this.oServer.close();		} catch (IOException e) {			e.printStackTrace();		}	}	/**	 * This method handles any messages received from server UI.	 *	 * @param message The message received from the client.	 */	public void handleMessageFromServerUI(String message) {		if(message.startsWith("#")){			message = message.substring(1);			String[] args = message.split(" ");			this.handleServerUICommand(args);		}	}	/**	 * This method handles commands from serverUI	 *	 * @param args[0] The command message received from the server client.	 * @param args[1] The param for setport configuration.	 */	private void handleServerUICommand(String[] args) {		if(args.length >= 1) {			if("quit".equals(args[0])) {				this.closeSafe();				System.exit(0);			} else if("stop".equals(args[0])) {				this.oServer.stopListening();			} else if("close".equals(args[0])) {				this.closeSafe();			} else if("setport".equals(args[0])) {				if(!this.oServer.isListening()){					if(args.length >= 2) {						try {							int newPort = Integer.parseInt(args[1]);							int oldPort = this.oServer.getPort();							this.oServer.setPort(newPort);							this.serverUI.display("The port change from " + oldPort + " to " + newPort + ".");						} catch(NumberFormatException e) {							serverUI.display("The port should be a number.");						}					}					else {						serverUI.display("The port should be write.");					}				} else {					serverUI.display("You should close the connection.");				}			} else if("getport".equals(args[0])) {				serverUI.display(String.valueOf(this.oServer.getPort()));			} else if("start".equals(args[0])) {				if(!this.oServer.isListening()){					try {						this.oServer.listen();					} catch (IOException e) {						e.printStackTrace();					}				}			}			else {				serverUI.display("Invalid command.");			}		}		else {			serverUI.display("Invalid command.");		}	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server starts listening for connections.	 */	protected void serverStarted()	{		this.serverUI.display("Server listening for connections on port " + this.oServer.getPort());	}	/**	 * This method overrides the one in the superclass.  Called	 * when the server stops listening for connections.	 */	protected void serverStopped()	{		this.serverUI.display("Server has stopped listening for connections.");	}	/**	 * Connection from client	 * 	 * @param client The connection from which the connections come from.	 * 	 */	public void clientConnected(ConnectionToClient client) {		this.serverUI.display("Client connected : " + client.getInetAddress().getHostAddress());	}	/**	 * Sympa disconnection from client	 * 	 * @param client The connection from which the message originated.	 * 	 */	synchronized protected void clientDisconnected(ConnectionToClient client) {		this.serverUI.display("This client is disconnected: " + client.getInetAddress().getHostAddress());	}	/**	 * Brutal disconnection from client	 * 	 * @param client The connection from which the message originated.	 * @param exception The exception received from server.	 * 	 */	protected synchronized void clientException(ConnectionToClient client, String exception) {		this.serverUI.display("A client is disconnected.");	}		/**	 * Implementation of update() method from observer class	 * @param o Observable object	 * @param arg Object	 */	@Override	public void update(Observable o, Object arg) {		String message = "";		OriginatorMessage originatorMessage = null;		ConnectionToClient client = null;		if(arg instanceof OriginatorMessage){			originatorMessage = (OriginatorMessage) arg;			message = originatorMessage.getMessage().toString();				client = originatorMessage.getOriginator();		}		if(message.startsWith(ObservableOriginatorServer.LISTENING_EXCEPTION)){return;}		if(message.startsWith(ObservableOriginatorServer.CLIENT_EXCEPTION)){this.clientException(client, message);return;}		switch(message){			case ObservableOriginatorServer.SERVER_STARTED: this.serverStarted(); break;			case ObservableOriginatorServer.SERVER_STOPPED: this.serverStopped(); break;			case ObservableOriginatorServer.CLIENT_CONNECTED: this.clientConnected(client);	break;			case ObservableOriginatorServer.CLIENT_DISCONNECTED: this.clientDisconnected(client); break;			case ObservableOriginatorServer.SERVER_CLOSED: break;			default: {				if(message.startsWith("#")) {					message = message.substring(1);					String[] args = message.split(" ");					if("login".equals(args[0])) {						this.callCommandFromClient(args, client);					} else {						try {							client.sendToClient("You can only use command #login.");						} catch (IOException e) {						}					}						} else {					String[] args = new String[2];					args[0] = "sendToAllClients";					args[1] = message;					this.callCommandFromClient(args, client);				}							}		}		} 	/**	 * Method that handle commands from client side	 * 	 * @param args[0] type of param {logoff, login, sendToAllClients} that is being used	 * @param client The connection from which the message originated.	 * 	 */	public void callCommandFromClient(String[] args, ConnectionToClient client) {		if(args.length >= 1) {			if("logoff".equals(args[0])) {				if(client.getInfo("username") != null) {					try {						client.close();					} catch (IOException e) {						e.printStackTrace();					}					this.oServer.sendToAllClients(client.getInfo("username") + " is disconected.");				}				else {					try {						client.sendToClient("You must be logged in to do that.");					} catch (IOException e) {}				}			}			else if("login".equals(args[0])){				if(args.length >= 2){					if(client.getInfo("username") == null) {						client.setInfo("username", args[1]);						this.oServer.sendToAllClients("Welcome "+client.getInfo("username") + " [connected]");					} else {						try {							client.sendToClient("You are already logged.");						} catch (IOException e) {}					}					}			}			else if("sendToAllClients".equals(args[0])) {				if(client.getInfo("username") != null) {					if(args.length >= 2) {						this.oServer.sendToAllClients(client.getInfo("username") + ": " + args[1]);					}				}				else {					try {						client.sendToClient("You must be logged in to do that.");					} catch (IOException e) {}				}			}		}	}}//End of EchoServer class